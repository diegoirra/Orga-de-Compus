\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{mips}
\usepackage[spanish]{babel}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\begin{document}

\date{26 de Septiembre del 2017}

\title{Univesidad de Buenos Aires - FIUBA \\ 66:20 Organización de Computadoras \\ Trabajo práctico 1: Programación MIPS}

\author{Barrera Oro, Rafael (83240) \\ Bacigaluppo, Ivan (98064) \\ Irrazabal, Diego (98125)}

\maketitle

\thispagestyle{empty}

\newpage

\setcounter{page}{1}

\tableofcontents

\newpage

\section{Documentación}

\subsection{Diseño}

Este segundo tp es más complejo que el anterior puesto que el objetivo es familiarizarse con las instrucciones de MIPS y el concepto de ABI.

Comenzamos realizando un archivo makefile bastante simple, con algunos flags, para poder compilarlo y ejecutarlo en cuanto antes. Para así poder empezar a probar cualquier cambio que hicieramos, y asegurarnos que compilara adecuadamente con el comando make. Este makefile compilaría el código mediante los siguientes comandos:

	gcc -g -Wall -o tp1 main.c

Luego comenzamos con el código ya propio de lo pedido en la consigna. En primer lugar, al igual que para el TP0, armamos el main de manera que distinguiese que opción se había ingresado para ejecutar el programa. Al verificar esto, armamos una función para el comando -h, la cual imprime lo pedido; con el comando -V directamente la versión y, por último, hay una función encargada de verificar cual es el archivo de entrada, cual es el de salida del programa y cuales los buffer de entrada y salida. En los primeros dos casos el programa termina inmediatamente después de la impresión.

Luego de esto, se llama a una función handle que recibe los argumentos correspondientes como parámetros si los hubiese, o NULL en caso contrario. Esta función se encarga de procesar los archivos de entrada y salida, o asiganar los inputo o output standard para trabajar si alguno hubiera sido pasado como NULL.

Siguiendo el modelo de implementación incremental, en una primera básica versión esta función requeriría un archivo input existente, e imprimiría el resultado por la consola. De esta forma se simplifica la verificación del correcto funcionamiento del programa.

Finalmente, handle realiza la verificacion del archivo de entrada. Si lo recibido para este mismo es distinto de NULL, lo abre para lectura; en caso contrario, toma como entrada por defecto la terminal (stdin). Luego, de manera similar, verifica el archivo de salida. Si es distinto de NULL, lo abre pero para escritura en este caso y, de manera contraria, si no se le pasó por comando de entrada, utiliza por defecto la terminal como salida (stdout). Cualquier error en la apertura de los archivos se informa mediante la salida estándar stderr.

A continuación, se llama a la función is_pal, la cual está codificada en MIPS, tal como pide la consigna. Internamente esta función hace un llamado a getch, una función que se encunetra en otro módulo, en donde se procesa el archivo. Para esto se crea un buffer, utilizando la función mymalloc proporcionada por la cátedra. Luego este buffer se llena mediante una llamada a la syscall read.

Una vez que se tiene el buffer ya cargado, se pasa a leer una por una las palabras del mismo. Para esto nos encontramos con una dificultad que todavía no pudimos resolver, la cual es como separar las palabras en MIPS. Luego, cada una de las palabras debería pasar por la función strlen, la cual devuelve la longitud de ellas. Una vez que se obtiene esta longitud se pasa a un loop en el cual se verifica si la palabra es o no un palíndromo. En caso de que lo sea, se debería hacer una llamada a putch, la cual todavía no se encuentra implementada, pero que internamente debería llenar un buffer de salida y llamar a la syscall write.

Una vez que esté finalizado el código por completo procederemos a probarlo de la misma manera que en el tp0, mediante pruebas automatizadas que se pueden correr directamente desde el makefile.

\newpage

\subsection{Implementación}

\subsubsection{void print\_version()}

Imprime la version del programa por consola.

\subsubsection{void print\_usage()}

Imprime la leyenda de ayuda del programa por consola.

\subsubsection{int palindrome(int ifd, size\_t ibytes, int ofd, size\_t obytes)}

Recibe un input file descriptor, un tamaño de bytes para los buffer de lectura, un output file descriptor y un tamañao de bytes para los buffers de salida. Internamente llama a la función implementada en MIPS is_pal.

\subsubsection{void handle(char* input\_file\_name, char* output\_file\_name, int input\_buffer, int output\_buffer,)}

Recibe punteros a los nombres completos de los archivos de entrada y salida, procede a ejecutar la logica completa del programa, mediante el llamado a la función de MIPS (si algun nombre es equivalente a "-" se reemplaza por la entrada/salida estandar). A su vez, recibe los tamaños de los buffer de entrada y salida.

\subsubsection{int main(int argc, char** argv)}

Punto de entrada al programa, se procesan los parametros recibidos de linea de comando y se ejecuta la logica del programa de ser correctos, de lo contrario se muestra la leyenda de ayuda.

\subsection{Compilación}

\lstset{
	breaklines=true,
  	basicstyle=\footnotesize,
}

Se ha incluido un archivo Makefile para simplificar la obtención del ejecutable, el mismo puede obtenerse simplemente mediante la ejecución del comando \textit{make}, que generará un archivo binario \textit{tp1}:

\begin{lstlisting}[language=bash]
$ make
gcc -g -Wall -o tp1 tp1.c 
$ ls
tp1.c Makefile tp1 
\end{lstlisting}

\subsection{Ejecución}

Una vez obtenido el ejecutable, el mismo se puede ejecutar con el parámetro \textit{-h} para obtener la leyenda de ayuda:

\begin{lstlisting}[language=bash]
$ ./tp0 -h
Usage:
	tp1 -h
	tp1 -V
	tp1 [options]
Options:
	-V, --version	Print version and quit.
	-h, --help	Print this information.
	-i, --input	Location of the input file.
	-o, --output	Location of the output file.
  -I, --ibuf-bytes  Byte-count of the input buffer.
  -O, --obuf-bytes  Byte-count of the output buffer.
Examples:
	tp1 -i ~/input -o ~/output

\end{lstlisting}

O utilizando cualquiera de los parámetros requeridos por el enunciado:

\begin{lstlisting}[language=bash]
$ echo "somos todos bob" | ./tp1 -o pal.txt
$ cat pal.txt
somos
bob
\end{lstlisting}

\newpage

\section{Casos de prueba}

\subsection{Makefile}

Se puede utilizar el Makefile para correr casos de prueba:

\begin{lstlisting}[language=bash]
$ make test
gcc -g -Wall -o tp1 tp1.c 
./tp1 -i tests/test1.in > tests/test1.res
diff tests/test1.out tests/test1.res
./tp1 -i tests/test2.in > tests/test2.res
diff tests/test2.out tests/test2.res
./tp1 -i tests/test3.in > tests/test3.res
diff tests/test3.out tests/test3.res
./tp1 -i tests/test4.in > tests/test4.res
diff tests/test4.out tests/test4.res
\end{lstlisting}

\subsection{Validación de parámetros}

\subsubsection{Input}

\begin{lstlisting}[language=bash]
$ ./tp1 -i /tmp/noexiste.txt
No se pudo abrir el archivo de entrada: /tmp/noexiste.txt
\end{lstlisting}

\subsubsection{Output}

\begin{lstlisting}[language=bash]
$ echo "bob" |./tp1 -o /tmp/
No se pudo abrir el archivo de salida: /tmp/
\end{lstlisting}

\subsection{Utilizado entrada y salida standard}

\begin{lstlisting}[language=bash]
$ echo "somos bob hope"|./tp1 
somos
bob
\end{lstlisting}

\subsection{Utilizado archivos}

\begin{lstlisting}[language=bash]
$ echo "somos bob hope" >> test.txt
$ ./tp1 -i test.txt -o pal.txt
$ cat pal.txt 
somos
bob
\end{lstlisting}

\newpage

\section{Código fuente}

\subsection{C}

\lstset{
	breaklines=true,
  	basicstyle=\footnotesize,
	numbers=left,
	captionpos=b,
	showspaces=false,
	title=\lstname
}

\lstinputlisting[language=C]{tp1.c}

\newpage

\subsection{Assembly (MIPS)}

\lstset{
	breaklines=true,
  	basicstyle=\footnotesize,
}

\begin{lstlisting}[language=bash]
$ make asm
gcc -g -Wall -O0 -S tp1.c
Makefile tp0.c    tp1.s
\end{lstlisting}

\lstset{
  language=[mips]Assembler,       % the language of the code
  basicstyle=\footnotesize,       % the size of the fonts that are used for the code
  numbers=left,                   % where to put the line-numbers
  numberstyle=\tiny\color{gray},  % the style that is used for the line-numbers
  stepnumber=1,                   % the step between two line-numbers. If it's 1, each line 
  numbersep=5pt,                  % how far the line-numbers are from the code
  backgroundcolor=\color{white},  % choose the background color. You must add \usepackage{color}
  showspaces=false,               % show spaces adding particular underscores
  showstringspaces=false,         % underline spaces within strings
  showtabs=false,                 % show tabs within strings adding particular underscores
  frame=single,                   % adds a frame around the code
  rulecolor=\color{black},        % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. commens (green here))
  tabsize=4,                      % sets default tabsize to 2 spaces
  captionpos=b,                   % sets the caption-position to bottom
  breaklines=true,                % sets automatic line breaking
  breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
  title=\lstname,                 % show the filename of files included with \lstinputlisting;
  keywordstyle=\color{blue},          % keyword style
  commentstyle=\color{dkgreen},       % comment style
  stringstyle=\color{mauve},         % string literal style
  escapeinside={\%*}{*)},            % if you want to add a comment within your code
  morekeywords={*,...}               % if you want to add more keywords to the set
}

\lstinputlisting{.s}

\section{Conclusiones}

Dado que el trabajo no está terminado no hay muchas conclusiones para obtener. Lo que pudimos observar es que entender el lenguaje MIPS no es simple y lleva tiempo y trabajo. Esto se puede ver en que algo que fue muy simple en código C, como obtener palíndromos de un archivo, fue totalmente distinto al pasar a código fuente, en donde nos encontramos con muchas dificultades. A parte de esto, pudimos seguir familiarizandonos con herramientas como LaTex y la máquina virtual de gxemul, la cual nos permite levantar la imagen de NetBSD, sin la cual no podríamos trabajar con código MIPS.


\end{document}
